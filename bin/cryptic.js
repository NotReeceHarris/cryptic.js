#!/usr/bin/env node
const version="1.0",algorithm="aes-256-cbc",ellipticCurve="secp256k1",crypto=require("crypto"),inquirer=require("inquirer"),net=require("net"),socket=new net.Socket,server=net.createServer(),client=[],messageLogs=[],validation=require("./utils/validation"),color=require("./utils/color"),ui=require("./utils/ui"),readline=require("readline");server.on("connection",e=>{0===client.length?(client.push(e),e.on("close",()=>{client.splice(0,client.length)})):(e.end(),console.log(`${color.FgCyan}[${color.FgWhite}${new Date().toLocaleString("en-US",{hour:"numeric",minute:"numeric",day:"numeric",month:"numeric",year:"numeric"})}${color.FgCyan}] ${color.Bright}(Broadcast)${color.Reset}: A 3rd party connection just tried to connect to you. "${e.remoteAddress}"`))}),socket.on("data",async e=>{if(void 0===process.env.peerPublicKey&&e.toString("utf8").includes(":key-cryptic.js-v-1.0:")){let t=e.toString("utf8").split(":key-cryptic.js-v-1.0:");process.env.peerPublicKey=t[1];return}if(void 0===process.env.confirmedSharedKey&&e.toString("utf8").includes(":validate-sharedKey-cryptic.js-v-1.0:")){let o;await new Promise(t=>{o=setInterval(function(){if(void 0!=process.env.sharedKey&&void 0===process.env.confirmedSharedKey){let o=e.toString("utf8").split(":validate-sharedKey-cryptic.js-v-1.0:"),r=crypto.createHash("sha256").update(process.env.sharedKey).digest("hex"),n=Buffer.from(o[1].split(":iv:")[0],"hex"),i=Buffer.from(o[1].split(":iv:")[1],"base64"),c=Buffer.from(process.env.sharedKey,"hex"),a=crypto.createDecipheriv(algorithm,c,i),l=Buffer.concat([a.update(n),a.final()]).toString("hex");process.env.confirmedSharedKey=l===r,t()}},100)}),clearInterval(o);return}if(process.env.confirmedSharedKey&&e.toString("utf8").includes(":message-cryptic.js-v-1.0:")){let r=e.toString("utf8").split(":message-cryptic.js-v-1.0:"),n=Buffer.from(r[1],"base64"),i=Buffer.from(r[0],"base64"),c=Buffer.from(process.env.sharedKey,"hex"),a=crypto.createDecipheriv(algorithm,c,i),l=Buffer.concat([a.update(n),a.final()]).toString("utf8");if(l.includes(":timestamp:")){let s=l.split(":timestamp:")[1],g=parseInt(l.split(":timestamp:")[0]);messageLogs.push({timestamp:g,message:s,from:"peer"}),console.log(`${color.FgBlue}[${color.FgWhite}${new Date(g).toLocaleString("en-US",{hour:"numeric",minute:"numeric",day:"numeric",month:"numeric",year:"numeric"})}${color.FgBlue}] ${color.Bright}(Peer)${color.Reset}: ${s}`)}else messageLogs.push({timestamp:new Date().getTime(),message:"Couldn't decrypt message",from:"peer"})}}),socket.on("error",()=>{0!==client.length||process.env.confirmedSharedKey||console.log(`${color.FgRed}!${color.Reset}${color.Bright} Couldn't connect to peer, trying again in 5 seconds...${color.Reset}`),0===client.length&&process.env.confirmedSharedKey&&(console.log(`${color.FgRed}!${color.Reset}${color.Bright} The peer has disconnected${color.Reset}`),process.exit())}),console.log("\n"),console.log(`${color.FgCyan}Cryptic.js${color.FgWhite} V1.0${color.Reset}`),console.log(`${color.Dim}(https://github.com/NotReeceHarris/cryptic.js)${color.Reset}`),console.log("────────────────────────────────","\n"),(async()=>{let e,t;await inquirer.prompt([{type:"number",name:"port",message:"Which port would you like to set for listening?",validate:validation.listenPort},]).then(e=>{process.env.port=e.port}),await new Promise(e=>{server.listen(process.env.port,()=>{e()})}),console.log(`${color.FgGreen}!${color.Reset}${color.Bright} Now listing on port ${process.env.port}...${color.Reset}`),await inquirer.prompt([{type:"input",name:"peer_host",message:"What is the IP address of the device you wish to connect with?",default:"localhost",validate:validation.peerHost},{type:"number",name:"peer_port",message:"Which port is the device you wish to connect with listening on?",validate:validation.peerPort},]).then(e=>{process.env.peer_host=e.peer_host,process.env.peer_port=e.peer_port});let o=readline.createInterface({input:process.stdin,output:process.stdout});socket.on("connect",()=>{console.log("\x1b[32m!\x1b[0m\x1b[1m Connected to peer\x1b[0m")}),await new Promise(async t=>{await socket.connect(process.env.peer_port,process.env.peer_host,()=>{t()}),e=setInterval(function(){socket.connect(process.env.peer_port,process.env.peer_host,()=>{t()})},5e3)}),clearInterval(e),t=ui.showLoadingAnimation(`${color.Reset}${color.Bright} Waiting for peer to connect.${color.Reset}`),await new Promise(t=>{e=setInterval(function(){1===client.length&&t()},100)}),clearInterval(e),t(),console.log(`${color.FgGreen}!${color.Reset}${color.Bright} Peer connected from ${client[0].remoteAddress}:${client[0].remotePort}${color.Reset}`),t=ui.showLoadingAnimation(`${color.Reset}${color.Bright} Performing Elliptic Curve Diffie-Hellman protocol${color.Reset}`);let r=crypto.createECDH(ellipticCurve),n=r.generateKeys(),i=r.getPublicKey();process.env.privateKey=n,process.env.publicKey=i.toString("hex"),client[0].write(`${new Date().getTime()}:key-cryptic.js-v-1.0:${process.env.publicKey}`),await new Promise(t=>{e=setInterval(function(){"peerPublicKey"in process.env&&void 0!=process.env.peerPublicKey&&t()},100)}),await (async()=>{let e=await r.computeSecret(Buffer.from(process.env.peerPublicKey,"hex")),t=await crypto.createHash("sha256").update(e).digest("hex"),o=await crypto.pbkdf2Sync(t,"1.0",1e5,32,"sha256").toString("hex");process.env.derivedSharedKey=t,process.env.sharedKey=o})(),clearInterval(e),t(),console.log(`${color.FgGreen}!${color.Reset}${color.Bright} Elliptic Curve Diffie-Hellman exchange complete${color.Reset}`);let c=crypto.randomBytes(16),a=crypto.createCipheriv(algorithm,Buffer.from(process.env.sharedKey,"hex"),c),l=Buffer.concat([a.update(crypto.createHash("sha256").update(process.env.sharedKey).digest()),a.final()]);client[0].write(`${new Date().getTime()}:validate-sharedKey-cryptic.js-v-1.0:${l.toString("hex")}:iv:${c.toString("base64")}`),await new Promise(t=>{e=setInterval(function(){"confirmedSharedKey"in process.env&&void 0!=process.env.confirmedSharedKey&&t()},100)}),t(),process.env.confirmedSharedKey||(console.log(`${color.FgGreen}!${color.Reset}${color.Bright} Shared keys do not match, please try again. perhaps the peer is using a different version${color.Reset}`),process.exit()),console.log("\n","────────────────────────────────","\n"),console.log(` ${color.FgCyan}Peer${color.Reset}: ${client[0].remoteAddress}`),console.log(` ${color.FgCyan}Shared key checksum${color.Reset}: sha256 ${crypto.createHash("sha256").update(process.env.sharedKey).digest("hex")}`),console.log(` ${color.FgCyan}Encryption algorithm${color.Reset}: ${algorithm}`),console.log(` ${color.FgCyan}Elliptic curve${color.Reset}: ${ellipticCurve}`),console.log("\n","────────────────────────────────","\n"),console.log(`${color.FgCyan}[${color.FgWhite}${new Date().toLocaleString("en-US",{hour:"numeric",minute:"numeric",day:"numeric",month:"numeric",year:"numeric"})}${color.FgCyan}] ${color.Bright}(Broadcast)${color.Reset}: An "end to end" encrypted connection has been established, you may now type.`),o.on("line",async e=>{if(":q"===e&&process.exit(),""===e){readline.moveCursor(process.stdout,0,-1),readline.clearLine(process.stdout,1);return}let t=new Date().getTime();await (async()=>{readline.moveCursor(process.stdout,0,-1),readline.clearLine(process.stdout,1),console.log(`${color.FgCyan}[${color.FgWhite}${new Date(t).toLocaleString("en-US",{hour:"numeric",minute:"numeric",day:"numeric",month:"numeric",year:"numeric"})}${color.FgCyan}] ${color.Bright}(You)${color.Reset}: ${e}`);let o=crypto.randomBytes(16),r=crypto.createCipheriv(algorithm,Buffer.from(process.env.sharedKey,"hex"),o),n=Buffer.concat([r.update(`${t}:timestamp:${e}`),r.final()]);client[0].write(`${o.toString("base64")}:message-cryptic.js-v-1.0:${n.toString("base64")}`)})()})})();